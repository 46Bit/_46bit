---
title: Development Sparks
---
<p>When we encounter a problem as developers, there&#8217;s usually 3 ways to solve it. There&#8217;s the hacky way with its attendant long-term maintainance costs. There&#8217;s a way which works without too much trouble. And there&#8217;s the spark of genius that solves all the troubles with the minimum of effort.</p>

<p>As I&#8217;m sure you&#8217;ll like me appreciate doing the latter when possible, I thought I&#8217;d share a couple of them - one for keeping private config details of git repos, and the other for letting you write neater code for sliders and the like. I&#8217;m planning on making this into a regular series of posts whenever I come across similarly helpful tricks.</p>

<h2>Config templates in Git</h2>

<p>When developing a site, it&#8217;s more than easy to update your local database config file and then include that in your next code commit - and usually, that&#8217;s fine. The problem is that things like this make it easier for a compromise of one thing (your code repository for instance) to allow access to something potentially even more private (say, your company databases).</p>

<p>By default, there&#8217;s no obvious-to-all way to stop git from quite happily adding updated config files, short of making sure you remember not to every time you commit. Adding a path to .gitignore does nothing if it&#8217;s already in previous commits - and you don&#8217;t really want to have to manually add a config file every time you check code out.</p>

<p>The solution is the quite simple spark I <a href="http://blog.pagebakers.nl/2009/01/29/git-ignoring-changes-in-tracked-files/">first discovered here</a>: <code>git update-index --assume-unchanged &lt;path&gt;</code>. Simply run that and git will never notice any changes to the file. This way, you can add a basic template configuration file, and then change it to appropriate local details without having to worry about accidentally exposing them elsewhere.</p>

<h2>Everything is easy with the modulus</h2>

<p>A lot of the time, especially when dealing with sliders and the like, you come across code that requires a conditional check for a special case - going back to the first slide if you go past the last for instance. Whilst this works, there&#8217;s a trick to making it far neater and reliable: the modulus.</p>

<p>In this context, getting the modulus amounts to <strong>getting the remainder when one number is divided by another</strong>, and the symbol in programming is usually %. For example, <code>5 % 2 == 1</code> because <code>5 - 2 - 2 == 1</code>.</p>

<p>Say you&#8217;re coding a jQuery slider and want to go back to slide 1 once you reach the end. Counting from 0, the index of the next slide could be coded as <code>slideN = (slideN + 1 &gt;= slides.length) ? 0 : slideN + 1</code>. This checks if you are on the last slide, and if so then goes to the 0th slide rather than the next slide. On the other hand, it&#8217;s easier to write <code>slideN = (slideN + 1) % slides.length</code>. This does exactly the same.</p>

<p>Now the really neat thing: previous slides. Conditionally it&#8217;d be <code>slideN = (slideN - 1 &lt; 0) ? slides.length - 1 : slideN - 1</code>, which goes to the last slide if you're on the first one. Using a modulo, it&#8217;s neater <code>slideN = (slideN - 1 + slides.length) % slides.length</code>. When you can actually express the next slide as <code>slideN = (slideN + 1 + slides.length) % slides.length</code> as well, this gives you a really nice way to not have to worry about the scrolling direction for which logic to use, simply incrementing or decrementing as need be.</p>

<p>Once you get used to using %, neat uses pop up all over the place both in UI work and elsewhere.</p>
