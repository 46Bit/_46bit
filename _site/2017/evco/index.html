<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
  <title>Recursive Enum expression trees in Rust - 46b.it</title>
  <link href="https://fonts.googleapis.com/css?family=Merriweather:300|Open+Sans:300,400,400i,600" rel="stylesheet">
  <link href="/css/master.css" rel="stylesheet">
  <link rel="alternate" type="application/atom+xml" href="/meta/feed.atom">
  
</head>
<body>
  <header id="header">
    <div class="wrapper">
      <h1><a href="/">46b.it</a></h1>
      <nav>
        <ul>
          <li><a href="/">Writing</a></li>
          <li><a href="/wiki/">Wiki</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/46bit">Github</a></li>
        </ul>
      </nav>
    </div>
  </header>
  <article>
  <header class="prelude">
    <div class="wrapper">
      <p class="meta">March  3, 2017 <!--<i>&nbsp;&bullet;&nbsp; saturday &nbsp;&bullet;&nbsp; by Michael Mokrysz</i>--></p>
      <h1><a href="/2017/evco">Recursive Enum expression trees in Rust</a></h1>
    </div>
  </header>
  <section class="wrapper">
    <p>I mused about an implementation of expression trees in Rust <a href="https://46b.it/2017/rust-generating-syntax-trees/">two days ago</a>. This is to build a Genetic Programming library in Rust - an biologically-inspired approach to finding robust solutions to difficult problems.</p>
<p>As discussed elsewhere I’ve become a keen fan of Rust. This language’s limited generics pose interesting problems for expressing and generating equations as described above.</p>
<p>There are two common ways to represent a tree datastructure: <!--more--></p>
<ul>
<li>The most obvious way is similar to a Linked List: allocate a separate portion of memory for each node in the tree and store pointers to the child/parent nodes. This makes it cheap to expand the tree and is a very natural representation.</li>
<li>The other way is to put the tree into an array. Map the parent-child relationships into indices and you can store a tree as a single block of memory. Adding nodes can require copying all this data into a larger region of memory but this has a variety of benefits such as cache locality.</li>
</ul>
<p>We can define the semantics of a heap-allocated expression tree at compile time. Here’s a cut-down example - you can get and play with the <a href="https://play.rust-lang.org/?gist=ddbde8dbeacb4f501995aef551f5ac7f&amp;version=stable&amp;backtrace=0">full code here</a>.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="at">,</span> <span class="bu">Debug</span><span class="at">,</span> <span class="bu">PartialEq</span><span class="at">,</span> <span class="bu">Eq</span><span class="at">)]</span>
<span class="kw">enum</span> Equation <span class="op">{</span>
    Add(Node&lt;Equation&gt;, Node&lt;Equation&gt;), <span class="co">// `a + b`</span>
    Sub(Node&lt;Equation&gt;, Node&lt;Equation&gt;), <span class="co">// `a - b`</span>
    Mul(Node&lt;Equation&gt;, Node&lt;Equation&gt;), <span class="co">// `a * b`</span>
    Div(Node&lt;Equation&gt;, Node&lt;Equation&gt;), <span class="co">// `a / b`</span>
    Neg(Node&lt;Equation&gt;), <span class="co">// `-a`</span>
    Sin(Node&lt;Equation&gt;), <span class="co">// `sin(a)`</span>
    Float(<span class="dt">f64</span>), <span class="co">// evaluates to a constant 64-bit float</span>
    Input, <span class="co">// evaluates to an inputted 64-bit float</span>
<span class="op">}</span>

<span class="kw">impl</span> Equation <span class="op">{</span>
    <span class="kw">fn</span> eval(&amp;<span class="kw">self</span>, env: &amp;<span class="kw">Self</span>::Environment) -&gt; <span class="kw">Self</span>::Action <span class="op">{</span>
        <span class="kw">match</span> *<span class="kw">self</span> <span class="op">{</span>
            Add(<span class="kw">ref</span> left, <span class="kw">ref</span> right) =&gt; left.eval(env) + right.eval(env),
            Sub(<span class="kw">ref</span> left, <span class="kw">ref</span> right) =&gt; left.eval(env) - right.eval(env),
            Mul(<span class="kw">ref</span> left, <span class="kw">ref</span> right) =&gt; left.eval(env) * right.eval(env),
            Div(<span class="kw">ref</span> left, <span class="kw">ref</span> right) =&gt; protected_div(left.eval(env), right.eval(env)),
            Neg(<span class="kw">ref</span> left) =&gt; -left.eval(env),
            Sin(<span class="kw">ref</span> left) =&gt; left.eval(env).sin(),
            Float(i) =&gt; i,
            Input =&gt; *env,
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">fn</span> main() <span class="op">{</span>
    <span class="co">// represent the equation `x` and evaluate for `x=5`</span>
    <span class="kw">let</span> tree1 = Equation::Input;
    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, tree1.eval(<span class="dv">5.0</span>));

    <span class="co">// represent the equation `x * sin(4.0)` and evaluate for `x=-7.3`</span>
    <span class="kw">let</span> tree2 =
      Equation::Mul(
        node(Equation::Input),
        node(Equation::Sin(
          node(Equation::Float(<span class="dv">4.0</span>))
        ))
      );
    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, tree2.eval(-<span class="dv">7.3</span>));

    <span class="co">// represent the equation `x + sin(x)` and evaluate for `x=99.1` and `x=16.3`</span>
    <span class="kw">let</span> tree3 =
      Equation::Add(
        node(Equation::Input),
        node(Equation::Sin(
          node(Equation::Input)
        ))
      );
    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, tree3.eval(<span class="dv">99.1</span>), tree3.eval(<span class="dv">16.3</span>));
<span class="op">}</span></code></pre></div>
<p>This works for Genetic Programming and I’ve devised nice ways to randomly generate these trees - see the <a href="https://github.com/46bit/evco/blob/master/examples/symbolic_regression.rs">Symbolic Regression example</a> and (this might not be obvious) <a href="https://46bit.github.io/evco/evco/gp/tree"><code>evco::gp::tree</code></a>.</p>
<p>However this does limit flexibility. Using a generic tree datastructure would allow for easily introducing or removing sorts of nodes at compile time. I found that in DEAP this sort of flexibility helped for experimenting but tended not to stick around, so it might well be better.</p>
<p><em>That’s all for now, it’s time for bed. Sometime soon I’d like to write about <a href="https://www.theguardian.com/world/2017/mar/01/silicon-valley-sexual-harassment-startups">diversity experiences in tech</a>, and how EVCO generates trees.</em></p>
  </section>
</article>

	<script>
  // Tracking
  if (document.location.hostname != "localhost") {
    // GoSquared
    var GoSquared = {};
    GoSquared.acct = "GSN-207291-Q";
    (function(w){
      function gs(){
        w._gstc_lt = +new Date;
        var d = document, g = d.createElement("script");
        g.type = "text/javascript";
        g.src = "//d1l6p2sc9645hc.cloudfront.net/tracker.js";
        var s = d.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(g, s);
      }
      w.addEventListener ?
        w.addEventListener("load", gs, false) :
        w.attachEvent("onload", gs);
    })(window);

    // Google Analytics
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-22921213-1']);
    _gaq.push(['_trackPageview']);
    var ga = document.createElement('script');
    ga.type = 'text/javascript';
    ga.async = true;
    ga.src = 'https://ssl.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(ga, s);
  }
	</script>
</body>
</html>
