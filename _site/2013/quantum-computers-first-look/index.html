<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>46bit</title>
<script src="//use.typekit.net/uaf2fos.js"></script>
<script>try{Typekit.load();}catch(e){}</script>

<link rel="stylesheet" href="/css/master.css">
<link rel="alternate" type="application/atom+xml" href="/meta/feed.atom">
<body>
	<div class="wrapper">
		<header class="head">
			<h1><a href="/">46bit</a> by Michael Mokrysz</h1>
			<nav class="sitenav">
				<ul>
					<li><a href="/">Weblog</a></li>
					<li><a href="/about">About</a></li>
				</ul>
			</nav>
		</header>
		<div class="pagecontent">
			<article>
	<header>
		<h1><a href="/2013/quantum-computers-first-look">A first look at Quantum Computers</a></h1>
		<span class="date">February 11, 2013</span>
		
			<span class="tags">Comp Sci</span>
		
	</header>
	<div class="extended"><p>The computer in front of you is pretty powerful, but it can’t factor a 600-digit number before Earth gets cooked by the Sun. No supercomputer humanity does or could build could do that either, so it seemed a sure bet to base the security of some encryption schemes on factoring being (exponentially) hard. <!--more--></p>
<p>A quantum computer of sufficient size could do it using <a href="http://en.wikipedia.org/wiki/Shor%27s_algorithm">Shor’s algorithm</a>. It could also allow you to simulate n-body problems in reasonable (polynomial) time. Thus you could break RSA encryption or simulate the interior of the sun right down to the sub-atomic scale.</p>
<p>If you’ve ever looked at Physics like the two-slit experiment, what follows might seem a little reminiscent. That’s because it is.</p>
<h2 id="a-hardwired-machine">A hardwired machine</h2>
<p>In the early days, computers were often programmed by altering their wiring. Instead of running a program stored on disk, computers like <a href="http://en.wikipedia.org/wiki/ENIAC">ENIAC</a> had a number of units that were manually patched together every time you wanted to run a different program. You’d wire a floating-point multiplier up to vacuum tubes with it’s input, then wire the output up to the next stage.</p>
<p>The model of quantum computers looks a lot like that. You’re not going to sit in front of a quantum computer and write some C++ to define the program to run: rather you’ll have to wire it up for every different program. It’s not quite as simple as a metal wire either, since you’ve got to be very careful to not destroy the quantum effects you look to exploit.</p>
<p>I think it should be possible for a 2nd or 3rd generation computer to have this wiring quickly done by another computer, such that you could have most of the benefits of stored-programs. I speculate this mode of operation would be similar to programming modern FPGAs using VHDL, but I’ve not looked for research in this area yet.</p>
<h2 id="what-the-flip-is-a-qubit">What the flip is a qubit?</h2>
<p>A lot of people have heard that the quantum computer’s form of a <code>bit</code> is called a <code>qubit</code>. The principle behind them is relatively simple to read about but harder (as with everything in quantum mechanics) to appreciate.</p>
<p>An ordinary <code>bit</code> is either 0 or 1. There’s no middle ground. A <code>qubit</code> on the other hand can be both 0 and 1 right up until the moment you observe it. There’s a probability you’ll observe it as a 0, and another probability you’ll observe a 1. This probability as to which state it’s in is called superposition.</p>
<p>How you’d observe a <code>qubit</code> depends on your implementation of them, but it amounts to when you have an instrument measure their value. This measurement collapses the qubit into a classical state, so if you read the qubit again you’ll read the same value as you did earlier.</p>
<p>Stopping this collapse into classical state from happening to the qubits whilst you’re computing is known as quantum decoherence. It’s one of the greatest problems to building a practical quantum computer.</p>
<p>That’s it for a quick introduction. I’ve had to skip <a href="http://en.wikipedia.org/wiki/Quantum_entanglement">entanglement</a> for now until I’m a bit more comfortable explaining it from the point of view of quantum computation. Possible algorithms, some Math and implementation detail discussion is what I’ll start to discuss next time.</p></div>
</article>

		</div>
	</div>
	<script>
	  // Tracking
	  if (document.location.hostname != "localhost") {
	    // GoSquared
	    var GoSquared = {};
	    GoSquared.acct = "GSN-207291-Q";
	    (function(w){
	      function gs(){
	        w._gstc_lt = +new Date;
	        var d = document, g = d.createElement("script");
	        g.type = "text/javascript";
	        g.src = "//d1l6p2sc9645hc.cloudfront.net/tracker.js";
	        var s = d.getElementsByTagName("script")[0];
	        s.parentNode.insertBefore(g, s);
	      }
	      w.addEventListener ?
	        w.addEventListener("load", gs, false) :
	        w.attachEvent("onload", gs);
	    })(window);

	    // Google Analytics
	    var _gaq = _gaq || [];
	    _gaq.push(['_setAccount', 'UA-22921213-1']);
	    _gaq.push(['_trackPageview']);
	    var ga = document.createElement('script');
	    ga.type = 'text/javascript';
	    ga.async = true;
	    ga.src = 'https://ssl.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0];
	    s.parentNode.insertBefore(ga, s);
	  }
	</script>
</body>
</html>
